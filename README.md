## Вопрос №1

###### 1. Структура каталогов сервиса:

```
src/
 |--api/
   |----api.py
 |--db/
   |----base.py
   |----init_db.py
   |----models.py
   |----session.py
 |--schemas
   |----schemas.py
 |--services
   |----services.py
 |--main.py
```

###### 2. Где должна находиться бизнес-логика и почему:

Бизнес-логика должна находиться в модуле services, так как она не должна зависеть от HTTP,
должна быть простой в тестировании, масштабируема и безопасна для рефакторинга.

###### 3. Как организовать конфигурацию (env):

1. Передать параметры окружения через docker-compose.yml при запуске контейнеров;
2. Через переменные окружения ОС;
3. Комбинация 1 и 2.

###### 4. Как и чем логировать:

Использовать стандартный модуль logging, в большей степени в директориях api/, services/, db/,
так как там описаны важные события приложения. Есть поддержка уровней логов (DEBUG, INFO, WARNING, ERROR и др.)

###### 5. Как обрабатывать ошибки (ошибки валидации / ошибки БД):

* Ошибки валидации - проверяются входящие данные моделями Pydantic в FastApi, если структура данных не соответствует
  описанной схеме, то будет возвращаться HTTP 422 и бизнес логика не запускается
* Ошибки БД - обрабатывается результат транзакций, при неуспешной транзакции применяется правило атомарности -
  транзакция должна выполниться полностью или не выполниться вовсе, срабатывает rollback и логируется ошибка

## Вопрос №2

``
Дана таблица расчётов коммерческих предложений:
quote_id material_id qty unit_cost unit created_at
5123 118 100 23.5 kg 2024-01-10
5123 118 0.1 2.35 ton 2024-01-10
``

###### 1. Почему здесь есть проблема со стоимостью?

Одни и те же материалы выражены в разных единицах измерения, для корректного расчета и предотвращения
неожиданных и некорректных результатов необходима нормализация (приведение к единому формату)

###### 2. Как привести unit к единой системе?

Необходимо выбрать базовую единицу и фактор (коэффициент на который умножается значение для нормализации) перед
сохранением
***
Пример:

````
unit = data["unit"]
qty = data["qty"]
unit_cost = data["unit_cost"]

FACTOR = {
  "g": 1, 
  "kg": 1000, 
  "ton": 1_000_000
}

qty_normalized = qty * FACTOR[unit]  # количество в граммах
unit_cost_normalized = unit_cost / FACTOR[unit]  # цена за 1 грамм
````

И далее хранить в граммах

***

###### 3. Куда в архитектуре должен быть вынесен мэппинг единиц измерения — в код, БД, отдельную витрину?

При небольшом и постоянном количестве единиц измерения можно держать константой в коде, при увеличении количества
единиц измерения целесообразно хранить в БД. Также целесообразно перенести мэппинг в БД, если идет постоянное
добавление/удаление единиц измерения, так как хранение в БД не требует изменений в коде и последующего деплоя

###### 4. Как убедиться, что новые данные не сломают консистентность?

Покрыть тестами:

* Убедиться что такая единица измерения существует в справочном ресурсе
* Если есть массив ожидаемых данных, с которыми можно сопоставить полученный результат, то проверить на совпадения
* Документирование единиц измерения, при масштабировании в особенности

## Практическое задание

#### III. Написать один SQL-запрос, который возвращает 10 последних расчётов отсортированных по дате

```
SELECT 
   total_cost_rub
FROM calc_results
ORDER BY created_at desc
LIMIT 10;
```

#### Вызов API для получения результата:

* URL: http://localhost:8000/costs_list
* METHOD: GET

